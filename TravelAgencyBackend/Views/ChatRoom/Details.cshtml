@model TravelAgencyBackend.ViewModels.ChatRoomDetailViewModel
@{
    ViewData["Title"] = "與 " + Model.MemberName + " 的對話";
    var senderId = @ViewBag.EmployeeId; // 設定 ViewBag.EmployeeId
}

<h1>@ViewData["Title"]</h1>

<div class="mb-3">
    <a asp-action="Index" class="btn btn-secondary">返回聊天室列表</a>
</div>

<hr />

<!-- 訊息顯示區 -->
<div id="chatArea" class="border p-3 bg-light mb-4" style="max-height: 400px; overflow-y: auto;"></div>

<!-- 訊息輸入與送出 -->
<div class="mb-3 d-flex gap-2 align-items-center">
    <input id="messageInput" class="form-control" placeholder="輸入訊息..." />
    <input type="file" id="fileInput" accept="image/*" />
    <button id="recordBtn" class="btn btn-warning" type="button">🎤 錄音</button>
    @if (PermissionChecker.CanManageChatRooms)
    {
        <button id="sendBtn" class="btn btn-primary">送出</button>
    }
    else
    {
        <button class="btn btn-primary disabled" disabled>送出</button>
    }
</div>
<audio id="audioPreview" controls style="display: none;"></audio>

<!-- 通話按鈕 -->
<div class="mb-3">
    @if (PermissionChecker.CanManageChatRooms)
    {
        <button onclick="startCall(false)" class="btn btn-outline-primary">📞 語音通話</button>
        <button onclick="startCall(true)" class="btn btn-outline-success">📹 視訊通話</button>
    }
    else
    {
        <button class="btn btn-outline-primary disabled" disabled>📞 語音通話</button>
        <button class="btn btn-outline-success disabled" disabled>📹 視訊通話</button>
    }
</div>

<!-- 通話控制區 -->
<div id="callControls" class="mb-3" style="display: none;">
    <p id="callTimer" class="text-muted"></p>
    <p id="callStatus" class="fw-bold text-info">📞 來電中...</p>
    <button onclick="acceptCall()" class="btn btn-success">接聽</button>
    <button onclick="rejectCall()" class="btn btn-danger">拒絕</button>
    <button onclick="endCall()" class="btn btn-secondary">掛斷</button>
</div>

<!-- 音訊 / 視訊 -->
<div class="d-flex gap-3">
    <video id="localVideo" autoplay playsinline muted style="width: 240px; border: 1px solid #ccc;"></video>
    <video id="remoteVideo" autoplay playsinline style="width: 240px; border: 1px solid #ccc;"></video>
</div>

<audio id="remoteAudio" autoplay style="display: none;"></audio>

@section Scripts {
    <script src="https://cdnjs.cloudflare.com/ajax/libs/microsoft-signalr/7.0.5/signalr.min.js"></script>
    <script>
        const chatRoomId = @Model.ChatRoomId;
        const senderType = "Employee";
        const senderId = @senderId;
        const api = "https://localhost:7265";
        // const api = "https:travel-api.local:7265"

        let connection, localStream, remoteConnectionId, peer, incomingOffer;
        let callTimerInterval, callStartTime;
        let mediaRecorder, audioChunks = [], audioBlob = null, audioDuration = 0;

        document.getElementById("sendBtn")?.addEventListener("click", sendMessage);
        document.getElementById("recordBtn").addEventListener("click", handleRecording);

        setupConnection();

        async function setupConnection() {
            connection = new signalR.HubConnectionBuilder()
                .withUrl(api + `/chathub?userId=${senderId}&userType=${senderType}`)
                .withAutomaticReconnect()
                .build();

            connection.on("ReceiveMessage", appendMessage);
            connection.on("ReceiveCallOffer", async (fromId, offer) => {
                remoteConnectionId = fromId;
                incomingOffer = offer;
                showCallControls("📞 來電中...");
            });
            connection.on("ReceiveCallAnswer", async (fromId, answer) => {
                await peer.setRemoteDescription(new RTCSessionDescription(answer));
                updateCallStatus("✅ 通話中");
                startCallTimer();
            });
            connection.on("ReceiveIceCandidate", async (fromId, candidate) => {
                await peer.addIceCandidate(new RTCIceCandidate(candidate));
            });
            connection.on("CallRejected", () => {
                alert("❌ 對方已拒絕通話");
                endCall(false);
            });
            connection.on("ReceiveEndCall", () => {
                alert("📴 對方已掛斷");
                endCall(false);
            });

            await connection.start();
            await connection.invoke("JoinGroup", chatRoomId.toString());
            loadMessages();
        }

        async function sendMessage() {
            const messageInput = document.getElementById("messageInput");
            const fileInput = document.getElementById("fileInput");
            const audioPreview = document.getElementById("audioPreview");
            const text = messageInput.value.trim();
            const file = fileInput.files[0];

            if (!text && !file && !audioBlob) {
                alert("請輸入訊息或上傳圖片／語音");
                return;
            }

            if (file) {
                const formData = new FormData();
                formData.append("ChatRoomId", chatRoomId);
                formData.append("SenderType", senderType);
                formData.append("SenderId", senderId);
                formData.append("File", file);
                await fetch(api + "/api/messageupload/upload-image", {
                    method: "POST",
                    body: formData
                });
                fileInput.value = "";
            }

            if (audioBlob) {
                const formData = new FormData();
                formData.append("ChatRoomId", chatRoomId);
                formData.append("SenderType", senderType);
                formData.append("SenderId", senderId);
                formData.append("File", audioBlob, "recording.webm");
                formData.append("DurationInSeconds", isFinite(audioDuration) ? Math.floor(audioDuration) : 0);
                await fetch(api + "/api/messageupload/upload-audio", {
                    method: "POST",
                    body: formData
                });
                URL.revokeObjectURL(audioPreview.src);
                audioPreview.style.display = "none";
                audioPreview.src = "";
                audioBlob = null;
                audioDuration = 0;
            }

            if (text) {
                const payload = {
                    chatRoomId: chatRoomId,
                    senderType: senderType,
                    senderId: senderId,
                    messageType: "text",
                    content: text
                };
                await fetch(api + "/api/Messages", {
                    method: "POST",
                    headers: { "Content-Type": "application/json" },
                    body: JSON.stringify(payload)
                });
                messageInput.value = "";
            }
        }

        function handleRecording() {
            const btn = document.getElementById("recordBtn");
            if (mediaRecorder && mediaRecorder.state === "recording") {
                mediaRecorder.stop();
                btn.textContent = "🎤 錄音";
                return;
            }
            navigator.mediaDevices.getUserMedia({ audio: true }).then(stream => {
                mediaRecorder = new MediaRecorder(stream);
                audioChunks = [];
                mediaRecorder.ondataavailable = e => audioChunks.push(e.data);
                mediaRecorder.onstop = () => {
                    audioBlob = new Blob(audioChunks, { type: "audio/webm" });
                    const audioUrl = URL.createObjectURL(audioBlob);
                    const preview = document.getElementById("audioPreview");
                    preview.src = audioUrl;
                    preview.style.display = "block";
                    const temp = new Audio(audioUrl);
                    temp.addEventListener("loadedmetadata", () => {
                        audioDuration = temp.duration;
                    });
                };
                mediaRecorder.start();
                btn.textContent = "⏹️ 停止";
            });
        }

        async function loadMessages() {
            const res = await fetch(api + `/api/Messages/${chatRoomId}`);
            const messages = await res.json();
            messages.forEach(appendMessage);
        }

        function appendMessage(msg) {
            const chatArea = document.getElementById("chatArea");
            const div = document.createElement("div");
            div.className = "mb-2";
            let contentHtml = "";
            if (msg.messageType === "image") {
                contentHtml = `<img src="${msg.content}" alt="圖片訊息" style="max-width: 200px;" />`;
            } else if (msg.messageType === "audio") {
                contentHtml = `<audio src="${msg.content}" controls></audio>`;
            } else {
                contentHtml = msg.content;
            }
            div.innerHTML = `
                <strong>${msg.senderName}：</strong>
                ${contentHtml}
                <div class="text-muted small">${new Date(msg.sentAt).toLocaleString()}</div>
            `;
            chatArea.appendChild(div);
            chatArea.scrollTop = chatArea.scrollHeight;
        }

        // 通話相關邏輯
        async function startCall(useVideo = false) {
            const targetType = "Member";
            const targetId = parseInt("@Model.MemberId");

            const targetConnId = await connection.invoke("GetConnectionId", targetType, targetId);
            if (!targetConnId) return alert("對方未連線");

            remoteConnectionId = targetConnId;

            localStream = await navigator.mediaDevices.getUserMedia({ audio: true, video: useVideo });
            document.getElementById("localVideo").srcObject = localStream;

            peer = createPeerConnection();
            localStream.getTracks().forEach(track => peer.addTrack(track, localStream));

            const offer = await peer.createOffer();
            await peer.setLocalDescription(offer);
            await connection.invoke("SendCallOffer", targetConnId, offer);

            showCallControls("⏳ 等待對方接聽...");
        }

        async function acceptCall() {
            updateCallStatus("⏳ 接通中...");
            localStream = await navigator.mediaDevices.getUserMedia({ audio: true, video: true });
            document.getElementById("localVideo").srcObject = localStream;

            peer = createPeerConnection();
            localStream.getTracks().forEach(track => peer.addTrack(track, localStream));

            await peer.setRemoteDescription(new RTCSessionDescription(incomingOffer));
            const answer = await peer.createAnswer();
            await peer.setLocalDescription(answer);
            await connection.invoke("SendCallAnswer", remoteConnectionId, answer);

            updateCallStatus("✅ 通話中");
            startCallTimer();
        }

        async function rejectCall() {
            await connection.invoke("RejectCall", remoteConnectionId);
            endCall(false);
        }

        async function endCall(sendSignal = true) {
            if (localStream) {
                localStream.getTracks().forEach(t => t.stop());
                localStream = null;
                document.getElementById("localVideo").srcObject = null;
            }
            if (peer) {
                peer.close();
                peer = null;
            }
            document.getElementById("remoteAudio").srcObject = null;
            document.getElementById("remoteVideo").srcObject = null;
            document.getElementById("callControls").style.display = "none";
            stopCallTimer();

            if (sendSignal && remoteConnectionId) {
                await connection.invoke("EndCall", remoteConnectionId);
            }
        }

        function createPeerConnection() {
            const pc = new RTCPeerConnection({
                iceServers: [{ urls: "stun:stun.l.google.com:19302" }]
            });

            pc.onicecandidate = (e) => {
                if (e.candidate) {
                    connection.invoke("SendIceCandidate", remoteConnectionId, e.candidate);
                }
            };

            pc.ontrack = (e) => {
                const stream = e.streams[0];
                document.getElementById("remoteAudio").srcObject = stream;
                document.getElementById("remoteVideo").srcObject = stream;
            };

            return pc;
        }

        function showCallControls(text) {
            document.getElementById("callControls").style.display = "block";
            updateCallStatus(text);
        }

        function updateCallStatus(text) {
            document.getElementById("callStatus").innerText = text;
        }

        function startCallTimer() {
            callStartTime = new Date();
            updateCallTimer();
            callTimerInterval = setInterval(updateCallTimer, 1000);
        }

        function stopCallTimer() {
            clearInterval(callTimerInterval);
            document.getElementById("callTimer").innerText = "";
        }

        function updateCallTimer() {
            const now = new Date();
            const seconds = Math.floor((now - callStartTime) / 1000);
            const minutes = Math.floor(seconds / 60);
            const remaining = seconds % 60;
            document.getElementById("callTimer").innerText =
                `通話時間：${String(minutes).padStart(2, '0')}:${String(remaining).padStart(2, '0')}`;
        }
    </script>
}